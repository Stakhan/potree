<html>
<head>

<script src="../libs/three.js/build/three.js"></script>
<script src="../libs/other/OrbitControls.js"></script>
<script src="../src/Potree.js"></script>
<script src="../src/PointCloudOctree.js"></script>
<script src="../src/PointCloudOctreeGeometry.js"></script>
<script src="../src/loader/POCLoader.js"></script>
<script src="../src/loader/PointAttributes.js"></script>
<script src="../src/utils.js"></script>
<script src="../src/LRU.js"></script>
    
</head>
 <body style="margin: 0px; padding: 0px;">
 
 <style type="text/css">
 
#lblDistance{
	color:white;
	font-weight: bold;
	text-shadow:  2px  2px 2px black,
                  2px -2px 2px black,
                 -2px  2px 2px black,
                 -2px -2px 2px black;


}


 
 
 </style>

<script type="text/javascript">

var renderer;
var camera;
var scene;
var mouse = { x: 1, y: 1 };
var projector, raycaster;
var pointcloud;
var spStart, spEnd, sConnection;
var placeStartMode = false;
var placeEndMode = false;

function init() {
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
	
	projector = new THREE.Projector();
	raycaster = new THREE.Raycaster();

	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);
	
	// pointcloud
	var material = new THREE.PointCloudMaterial( { size: 0.02, vertexColors: true } );
	var pco = POCLoader.load("../resources/pointclouds/lion_takanawa/cloud.js");
	pointcloud = new Potree.PointCloudOctree(pco, material);
	pointcloud.LODDistance = 80;
	pointcloud.rotation.x = Math.PI;
	pointcloud.position.x = 8;
	pointcloud.position.z = -2;
	pointcloud.position.y = 4;
	scene.add(pointcloud);
	
	// grid
	scene.add(createGrid(8,8,1));
	
	// measurement
	var sphereGeometry = new THREE.SphereGeometry(0.05, 32, 32);
	var sphereMaterial = new THREE.MeshBasicMaterial({color: 0xbb0000, shading: THREE.FlatShading});
	spStart = new THREE.Mesh(sphereGeometry, sphereMaterial);
	spEnd = new THREE.Mesh(sphereGeometry, sphereMaterial);
	spStart.position.set(-1.1,1.05,2);
	spEnd.position.set(1.3,1.0,1.15);
	scene.add(spStart);
	scene.add(spEnd);
	
	var lc = new THREE.Color( 0xff0000 );
	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push(spStart.position.clone(), spEnd.position.clone());
	lineGeometry.colors.push(lc, lc, lc);
	var lineMaterial = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	sConnection = new THREE.Line(lineGeometry, lineMaterial);
	scene.add(sConnection);
	
	// controls
	camera.position.set(5,5,2);
	controls = new THREE.OrbitControls(camera);
	controls.target.set( 0, 3, 0 );
	camera.lookAt(new THREE.Vector3(0,3,0));
	
	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	renderer.domElement.addEventListener( 'click', onClick, false );
}

function createGrid(width, length, spacing){
	var material = new THREE.LineBasicMaterial({
        color: 0xBBBBBB
    });
	
	var geometry = new THREE.Geometry();
    for(var i = 0; i <= length; i++){
    	 geometry.vertices.push(new THREE.Vector3(-(spacing*width)/2, 0, i*spacing-(spacing*length)/2));
		 geometry.vertices.push(new THREE.Vector3(+(spacing*width)/2, 0, i*spacing-(spacing*length)/2));
    }
    
    for(var i = 0; i <= width; i++){
    	 geometry.vertices.push(new THREE.Vector3(i*spacing-(spacing*width)/2, 0, -(spacing*length)/2));
		 geometry.vertices.push(new THREE.Vector3(i*spacing-(spacing*width)/2, 0, +(spacing*length)/2));
    }
    
    var line = new THREE.Line(geometry, material, THREE.LinePieces);
    line.receiveShadow = true;
    return line;
}

function onDocumentMouseMove( event ) {
	event.preventDefault();

	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
}

function render() {			
	requestAnimationFrame(render);
	
	camera.updateMatrixWorld(true);
	
	vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	projector.unprojectVector( vector, camera );
	raycaster.params = {"PointCloud" : {threshold: 0.1}};
	raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );
	
	scene.traverse( function ( object ) {
		if ( object instanceof Potree.PointCloudOctree ) {
			object.update( camera );
		}
	} );
	
	if(placeStartMode || placeEndMode){
		var intersects = raycaster.intersectObject(pointcloud, true);
		
		if(intersects.length > 0){
			var I = intersects[0];
			
			if(placeStartMode){
				spStart.position = I.point;
			}else if(placeEndMode){
				spEnd.position = I.point;
			}
			sConnection.geometry.vertices[0].copy(spStart.position);
			sConnection.geometry.vertices[1].copy(spEnd.position);
			sConnection.geometry.verticesNeedUpdate = true;
			sConnection.geometry.computeBoundingSphere();
		}
	}
	
	// placing distance label
	var labelPos = spStart.position.clone().add(spEnd.position).multiplyScalar(0.5);
	projector.projectVector(labelPos, camera);
	labelPos.x = (labelPos.x + 1)/2 * window.innerWidth;
	labelPos.y = -(labelPos.y - 1)/2 * window.innerHeight;
	
	var distance = spStart.position.distanceTo(spEnd.position);
	var lblDistance = document.getElementById("lblDistance");
	lblDistance.style.left = labelPos.x;
	lblDistance.style.top = labelPos.y;
	lblDistance.innerHTML = distance.toFixed(2);

	renderer.render(scene, camera);
};

init();
render();

function placeStart(){	
	placeStartMode = true;
	placeEndMode = false;
}

function placeEnd(){
	placeStartMode = false;
	placeEndMode = true;
}

function onClick(){
	placeStartMode = false;
	placeEndMode = false;
}

</script>
 	
<input type="button" value="place start" 
	style="position:absolute; left: 10px; top: 10px; width: 100px; z-index: 100" 
	onclick="placeStart()">
<input type="button" value="place end" 
	style="position:absolute; left: 10px; top: 40px; width: 100px; z-index: 100"
	onclick="placeEnd()">
	
<div id="lblDistance" style="position: absolute; width: 20px; z-index: 100;">abc</div>
	
</body>
</html>

