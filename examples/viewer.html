

<html>
<head>
	<title>Lion</title>
	<style>canvas { width: 100%; height: 100% }</style>
</head>
<body style="margin: 0; padding: 0">

	<style type="text/css">
	
	.info{
		color:white;
		font-weight: bold;
		text-shadow:  1px  1px 1px black,
					  1px -1px 1px black,
					 -1px  1px 1px black,
					 -1px -1px 1px black;
	}
	
	a:hover, a:visited, a:link, a:active{
		color: #ccccff;
		text-decoration: none;
	}
	
	</style>

	<script src="../libs/plasio/js/laslaz.js"></script>
	<script src="../libs/plasio/vendor/bluebird.js"></script>
	<script src="../libs/three.js/build/three.js"></script>
	<script src="../libs/other/OrbitControls.js"></script>
	<script src="../libs/other/stats.min.js"></script>
	<script src="../libs/other/dat.gui.min.js"></script>
	
	<script src="../build/js/potree.min.js"></script>
	<script src="../src/PointCloudOctree.js"></script>
	<script src="../src/FloatingOrigin.js"></script>
	<script src="../src/TextSprite.js"></script>
	<script src="../src/Materials/PointCloudRGBMaterial.js"></script>
	<script src="../src/utils/LabelHelper.js"></script>
	
	
	<div id="lblNumVisibleNodes" class="info" style="position: absolute; left: 10px; top: 80px; width: 400px; color:white"></div>
	<div id="lblNumVisiblePoints" class="info" style="position: absolute; left: 10px; top: 100px; width: 400px; color:white"></div>
	<div id="lblCamOffset" class="info" style="position: absolute; left: 10px; top: 120px; width: 400px; color:white"></div>
	<div id="buttons" style="position: absolute; left: 10px; top: 140px; width: 400px; color:white">
		<input type="button" value="calculateProfile" onmousedown="calculateProfile()"/>
	</div>
	<div id="waypoints" class="info" style="position: absolute; left: 10px; top: 200px; width: 400px;  color:white; border: 1px solid black"></div>
	
	<div class="info" style="position: absolute; left: 300px; right: 300px; top: 10px; text-align: center;">
		<a href="http://potree.org" target="_blank">potree.org</a><br>
	</div>
	
	<script>
		var States = {
			DEFAULT: 1,
			PICKING: 2
		};
	
		var defaultPointSize = 1.3;
		var defaultLOD = 9;
		//var pointcloudPath = "../../../../pointclouds/bruno_friedmann/vol_total/vol_total_jpg_densified_point_cloud.las_converted/cloud.js";
		//var pointcloudPath = "../../../../pointclouds/bruno_friedmann/vol_total/tiled_converted/cloud.js";
		//var pointcloudPath = "../../../../pointclouds/bruno_friedmann/vol_total/small_tiles_converted/cloud.js";
		var pointcloudPath = "../../../../pointclouds/bruno_friedmann/vol_total/vol_total_bin/cloud.js";
	
		var renderer;
		var camera;
		var scene, sceneTools, sceneHUD, sceneMeasurement;
		var cameraHUD;
		var pointclouds = [];
		var milestones = [];
		var skybox;
		var stats;
		var clock = new THREE.Clock();
		var materials = {};
		var floatingOrigin;
		var iLabel;
		var mouse = { x: 1, y: 1 };
		var state = States.DEFAULT;
		var sConnection;
		var profileFrustum;
		var profile;
		
		var measurements = [];
		var activeMeasurement;
		
		function Measure(){
			this.points = [];
			this.spheres = [];
			this.edges = [];
			this.sphereLabels = [];
			this.edgeLabels = [];
		}

		var rtProfile = new THREE.WebGLRenderTarget( 1024, 1024, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
		
		function calculateProfile(centroid, forward, side, width, height, depth){
			
			//var start = new THREE.Vector3(-8, -2, 3 + 2*Math.sin(clock.getElapsedTime()));
			//var end = new THREE.Vector3(5, -2, 3 + 2*Math.sin(clock.getElapsedTime()));
            //
			//var width = 0.2;
			//var depth = 0;
			//
			////var points = pointclouds[0].getProfile(start, end, width, depth);
			//
			//if(sConnection === undefined){
			//	var lc = new THREE.Color( 0xff0000 );
			//	var lineGeometry = new THREE.Geometry();
			//	lineGeometry.vertices.push(start.clone(), end.clone());
			//	lineGeometry.colors.push(lc, lc, lc);
			//	var lineMaterial = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
			//	//lineMaterial.depthTest = false;
			//	sConnection = new THREE.Line(lineGeometry, lineMaterial);
			//	scene.add(sConnection);
			//}else{
			//	sConnection.geometry.vertices[0].copy(start);
			//	sConnection.geometry.vertices[1].copy(end);
			//	sConnection.geometry.verticesNeedUpdate = true;
			//}
			//
			//
			//var geometry = new THREE.SphereGeometry(0.1, 8, 8);
			//var material = new THREE.MeshNormalMaterial();
			//for(var i = 0; i < points.length; i++){
			//	var point = points[i];
			//	var sphere = new THREE.Mesh(geometry, material);
			//	sphere.position.copy(point);
			//	scene.add(sphere);
			//}
			
			if(profileFrustum === undefined){
				var boxGeometry = new THREE.BoxGeometry(1,1,1,1,1,1);
				var boxMaterial = new THREE.MeshBasicMaterial({color: 0xFF0000, transparent: true, opacity: 0.5});
				profileFrustum = new THREE.Mesh(boxGeometry, boxMaterial);
				
				sceneTools.add(profileFrustum);
			}		

			profileFrustum.scale.set(width, height, depth);
			
			
			var up = new THREE.Vector3().crossVectors(side, forward);
			
			var camera = new THREE.OrthographicCamera( -width / 2, width / 2, height / 2, -height / 2, 1, 1 + depth );
			//var camera = new THREE.OrthographicCamera( -width, width, height, -height, -depth/2, depth/2 );
			
			camera.position.copy(centroid.clone().add(forward));
			camera.lookAt(centroid);
			//camera.position.sub(forward);
			
			profileFrustum.position.copy(centroid.clone().add(forward));
			//profileFrustum.position.copy(centroid.clone().add(forward));
			profileFrustum.lookAt(centroid);
			profileFrustum.position.sub(forward);
			
			
			var oldSize = pointclouds[0].material.size;
			pointclouds[0].material.size = 0;
			renderer.render(scene, camera, rtProfile, true);
			pointclouds[0].material.size = oldSize;
			
			
			
		}
		
		function initGUI(){
		
			// dat.gui
			var gui = new dat.GUI({
				height : 5 * 32 - 1
			});
			
			var params = {
				PointSize: defaultPointSize,
				LOD: defaultLOD,
				"show aabb" : false,
				"Materials" : materials.rgb
			};
			
			var pLOD = gui.add(params, 'LOD', 0.5,20);
			pLOD.onChange(function(value){
				pointclouds[0].LOD = value;
			});
			
			var pPointSize = gui.add(params, 'PointSize', 0.01, 2.0);
			pPointSize.onChange(function(value){
				pointclouds[0].material.size = value;
			});
			
			var pMaterial = gui.add(params, 'Materials', [ "RGB", "Color", "Height" ]);
			pMaterial.onChange(function(value){
				var size = pointclouds[0].material.size;
				if(value === "RGB"){
					pointclouds[0].material = materials.rgb;
				}else if(value === "Color"){
					pointclouds[0].material = materials.color;
				}else if(value === "Height"){
					pointclouds[0].material = materials.height;
				}
				
				pointclouds[0].material.size = size;
			
				console.log(value);
			});
			
			var pBoundingBox = gui.add(params, 'show aabb');
			pBoundingBox.onChange(function(value){
				pointclouds[0].showBoundingBox = value;
			});

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.margin = '5px';
			document.body.appendChild( stats.domElement );
			
		}
		
		function initThree(){
			scene = new THREE.Scene();
			sceneHUD = new THREE.Scene();
			sceneTools = new THREE.Scene();
			sceneMeasurement = new THREE.Scene();
			
			camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100000);
			//cameraHUD = new THREE.OrthographicCamera( 500, 500, 500, 500, -1000, 1000);
			//cameraHUD = new THREE.OrthographicCamera( -1.6, 5, 2, -2, -5, 1000 );
			cameraHUD = new THREE.OrthographicCamera( -1, 1, 1, -1, -100, 1000 );
			//cameraHUD = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100000);
			//cameraHUD.position.set(0,0,100);
			cameraHUD.lookAt( new THREE.Vector3(0,0,0));
			floatingOrigin = new FloatingOrigin(camera);

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.autoClear = false;
			document.body.appendChild(renderer.domElement);
			
			skybox = Potree.utils.loadSkybox("../resources/textures/skybox/");

			// camera and controls
			camera.position.set(5050, 158, 600);
			controls = new THREE.FirstPersonControls(camera, renderer.domElement);
			camera.rotation.order = 'ZYX';
			camera.rotation.x = -0.5;
			camera.rotation.y = -Math.PI/4;
			controls.moveSpeed *= 10;
			//camera.rotati9o

			// materials
			materials.rgb = new Potree.PointCloudRGBMaterial({ size: defaultPointSize});
			materials.color = new Potree.PointCloudColorMaterial({size: defaultPointSize});
			materials.height = new Potree.PointCloudHeightMaterial({size: defaultPointSize, min: 0, max: 10});
			materials.height = new Potree.PointCloudHeightMaterial({size: defaultPointSize, min: 0, max: 10});
			
			// load pointcloud
			var pco = POCLoader.load(pointcloudPath, {toOrigin: true});
			
			// create nodes for large coordinates
			var count = 1;
			for(var i = 0; i < count; i++){
				var pointcloud = new Potree.PointCloudOctree(pco, materials.rgb);
				pointcloud.LOD = defaultLOD;
				//pointcloud.rotation.set(Math.PI/2, 0.85* -Math.PI/2, -0.0);
				pointcloud.applyMatrix(new THREE.Matrix4().set(
					1,0,0,0,
					0,0,1,0,
					0,1,0,0,
					0,0,0,1
				));
				pointcloud.position.set(0, 0, -Math.pow(2,i));
				pointcloud.floatingOrigin = true;
				//pointcloud.showBoundingBox = true;
				
				
				pointclouds.push(pointcloud);
				scene.add(pointcloud);
				
				//var spritey = makeTextSprite( Potree.utils.addCommas(-pointcloud.position.z), { fontsize: 32, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0} } );
				var spritey = Potree.LabelHelper.createTextSprite( Potree.utils.addCommas(-pointcloud.position.z), { fontsize: 32, fontface: "Georgia", borderColor: {r:0, g:0, b:255, a:1.0} } );
				spritey.position.set(0,0,pointcloud.position.z+3);
				scene.add( spritey );
				//milestones.push(spritey);
				
				floatingOrigin.addReferenceFrame(pointcloud);
				floatingOrigin.addReferenceFrame(spritey);
			}
			
			// create waypoints
			var elWaypoints = document.getElementById("waypoints");
			for(var i = 0; i < count; i++){
				var pos = -Math.pow(2,i);
				var div = document.createElement("div");
				div.innerHTML = Potree.utils.addCommas(-pos);
				//div.style.position = "absolute";
				//div.style.top = 200 + 30*i;
				//div.style.width = 120;
				div.style.padding = "1 2 1 2";
				div.style.margin = "1 2 1 5";
				//div.style.border = "1px solid black";
				div.style.float = "left";
				div.style.textDecoration = "underline";
				div.onclick = (function(pos){
					
					return function(){
						camera.position.z = -floatingOrigin.offset.z + pos + 25;
					};
					
				})(pos);
				elWaypoints.appendChild(div);
			}
			
			
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			
			
			var profileGeometry = new THREE.BoxGeometry(1,1,1);
			var profileMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, map: rtProfile } );
			profileMaterial.depthTest = false;
			//var profileMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			profile = new THREE.Mesh(profileGeometry, profileMaterial);
			//profile.scale.set(0.1, 0.1, 0.1);
			profile.scale.set(1,1,0.1);
			
			profile.position.set(0, 0, 0);
			sceneHUD.add(profile);
			
			
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'dblclick', onDoubleClick, false );
			renderer.domElement.addEventListener( 'mousedown', onClick, true );
		}
		
		function onClick(event){
			if(event.which == 3){	
				onRightClick();
			}
		}
		
		
		function onRightClick(){
			if(state == States.PICKING){
				var sphere = activeMeasurement.spheres.pop();
				var edge = activeMeasurement.edges.pop();
				var sphereLabel = activeMeasurement.sphereLabels.pop();
				var edgeLabel = activeMeasurement.edgeLabels.pop();
				
				sceneMeasurement.remove(sphere);
				sceneMeasurement.remove(edge);
				sceneMeasurement.remove(sphereLabel);
				sceneMeasurement.remove(edgeLabel);
			
				measurements.push(activeMeasurement);
				activeMeasurement = undefined;
			
				state = States.DEFAULT;
			}
		}
		
		function onDoubleClick(){
			var I = getMousePointCloudIntersection();
			if(I){
			
				if(state = States.DEFAULT){
					state = States.PICKING;
					activeMeasurement = new Measure();
				}
				
				var pos = I.clone().add(floatingOrigin.offset);
			
				var sphereMaterial = new THREE.MeshNormalMaterial({shading: THREE.SmoothShading})
				var sphereGeometry = new THREE.SphereGeometry(0.05, 10, 10);
				
				var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphere.position.copy(I);
				sceneMeasurement.add(sphere);
				
				var sphereEnd = new THREE.Mesh(sphereGeometry, sphereMaterial);
				sphereEnd.position.copy(I);
				sceneMeasurement.add(sphereEnd);
				
				var msg = pos.x.toFixed(2) + " / " + pos.y.toFixed(2) + " / " + pos.z.toFixed(2);
				
				var label = new Potree.TextSprite(msg);
				label.setBorderColor({r:0, g:255, b:0, a:1.0});
				label.material.depthTest = false;
				label.material.opacity = 0;
				label.position.copy(I);
				label.position.y += 0.5;
				sceneMeasurement.add( label );
				
				var labelEnd = new Potree.TextSprite(msg);
				labelEnd.setBorderColor({r:0, g:255, b:0, a:1.0});
				labelEnd.material.depthTest = false;
				labelEnd.material.opacity = 0;
				labelEnd.position.copy(I);
				labelEnd.position.y += 0.5;
				sceneMeasurement.add( labelEnd );
				
				var lc = new THREE.Color( 0xff0000 );
				var lineGeometry = new THREE.Geometry();
				lineGeometry.vertices.push(I.clone(), I.clone());
				lineGeometry.colors.push(lc, lc, lc);
				var lineMaterial = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
				lineMaterial.depthTest = false;
				sConnection = new THREE.Line(lineGeometry, lineMaterial);
				sceneMeasurement.add(sConnection);
				
				var edgeLabel = new Potree.TextSprite(0);
				edgeLabel.setBorderColor({r:0, g:255, b:0, a:0.0});
				edgeLabel.setBackgroundColor({r:0, g:255, b:0, a:0.0});
				edgeLabel.material.depthTest = false;
				edgeLabel.position.copy(I);
				edgeLabel.position.y += 0.5;
				sceneMeasurement.add( edgeLabel );
				
				
				floatingOrigin.addReferenceFrame(sphere);
				floatingOrigin.addReferenceFrame(sphereEnd);
				floatingOrigin.addReferenceFrame(label);
				floatingOrigin.addReferenceFrame(labelEnd);
				floatingOrigin.addReferenceFrame(sConnection);
				floatingOrigin.addReferenceFrame(edgeLabel);
				
				activeMeasurement.points.push(I);
				activeMeasurement.spheres.push(sphere);
				activeMeasurement.spheres.push(sphereEnd);
				activeMeasurement.sphereLabels.push(label);
				activeMeasurement.sphereLabels.push(labelEnd);
				activeMeasurement.edges.push(sConnection);
				activeMeasurement.edgeLabels.push(edgeLabel);
				
			}
		}
		
		function getMousePointCloudIntersection(){
			var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
			var projector = new THREE.Projector();
			projector.unprojectVector( vector, camera );
		
			var raycaster = new THREE.Raycaster();
			raycaster.params = {"PointCloud" : {threshold: 0.5}};
			raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );
			
			var intersects = raycaster.intersectObjects(pointclouds, true);
			
			if(intersects.length > 0){
				var I = intersects[0];
				return I.point;
			}else{
				return undefined;
			}
		}
		
		function onDocumentMouseMove( event ) {
			event.preventDefault();

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		}
		
		function render() {
			requestAnimationFrame(render);
			
			var numVisibleNodes = 0;
			var numVisiblePoints = 0;
			for(var i = 0; i < pointclouds.length; i++){
				var pointcloud = pointclouds[i];
				
				
				numVisibleNodes += pointcloud.numVisibleNodes;
				numVisiblePoints += pointcloud.numVisiblePoints;
				pointcloud.update(camera);
			}
			
			document.getElementById("lblNumVisibleNodes").innerHTML = "visible nodes: " + numVisibleNodes;
			document.getElementById("lblNumVisiblePoints").innerHTML = "visible points: " + Potree.utils.addCommas(numVisiblePoints);
			stats.update();
			
			controls.update(clock.getDelta());
			
			floatingOrigin.update();
			
			if(state == States.PICKING && activeMeasurement){
				var I = getMousePointCloudIntersection();
				
				if(I){
					var pos = I.clone().add(floatingOrigin.offset);
					var l = activeMeasurement.spheres.length;
					var sphere = activeMeasurement.spheres[l-1];
					var label = activeMeasurement.sphereLabels[l-1];
					var edge = activeMeasurement.edges[l-2];
					var edgeLabel = activeMeasurement.edgeLabels[l-2];
					
					var msg = pos.x.toFixed(2) + " / " + pos.y.toFixed(2) + " / " + pos.z.toFixed(2);
					label.setText(msg);
					
					sphere.position.copy(I);
					label.position.copy(I);
					label.position.y += 0.5;
					
					edge.geometry.vertices[1].copy(I);
					edge.geometry.verticesNeedUpdate = true;
					edge.geometry.computeBoundingSphere();
					
					var edgeLabelPos = edge.geometry.vertices[1].clone().add(edge.geometry.vertices[0]).multiplyScalar(0.5);
					var edgeLabelText = edge.geometry.vertices[0].distanceTo(edge.geometry.vertices[1]).toFixed(2);
					edgeLabel.position.copy(edgeLabelPos);
					edgeLabel.setText(edgeLabelText);
					edgeLabel.scale.multiplyScalar(10);
				}
			}
			
			//var centroid = new THREE.Vector3(-2, -4 + 3*Math.sin(clock.getElapsedTime()), 3);
			//var centroid = new THREE.Vector3(2000, 100 , 500);
			var centroid = new THREE.Vector3(5147, 108, 400);
			var forward = new THREE.Vector3(-1, 0, 0);
			var side = new THREE.Vector3(0, 0, -1);
			
			
			//var centroid = new THREE.Vector3(0, -3, 3);
			//var forward = new THREE.Vector3( 0, 0, 1 ).applyQuaternion(camera.quaternion);
			//var side = new THREE.Vector3( 1, 0, 0 ).applyQuaternion(camera.quaternion);
			
			calculateProfile(centroid, forward, side, 200, 200, 1.5);
			profile.scale.x = 1;
			profile.scale.y = renderer.domElement.clientWidth / renderer.domElement.clientHeight;
			profile.scale.multiplyScalar(0.5);
			profile.position.x = 0.7;
			profile.position.y = 0.5;
			
			
			// render skybox
			skybox.camera.rotation.copy(camera.rotation);
			renderer.render(skybox.scene, skybox.camera);
			
			// render scenes
			renderer.render(scene, camera);
			renderer.render(sceneTools, camera);
			renderer.render(sceneMeasurement, camera);
			renderer.render(sceneHUD, cameraHUD);
			
		};
		
		
		
		initThree();
		initGUI();
		render();
		
	</script>
	
</body>
</html>