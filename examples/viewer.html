<html>
<head>
	<meta charset="utf-8"/>
	<title>Lion</title>
	<style>canvas { width: 100%; height: 100% }</style>
</head>
<body style="margin: 0; padding: 0">

	<style type="text/css">
	
	#renderArea{
		width: 100%;
		height: 100%;
	}
	
	.info{
		color:		white;
		font-weight: bold;
		text-shadow:  1px  1px 1px black,
					  1px -1px 1px black,
					 -1px  1px 1px black,
					 -1px -1px 1px black;
	}
	
	a:hover, a:visited, a:link, a:active{
		color: #ccccff;
		text-decoration: none;
	}
	
	</style>

	<script src="../libs/plasio/js/laslaz.js"></script>
	<script src="../libs/plasio/vendor/bluebird.js"></script>
	<script src="../libs/three.js/build/three.js"></script>
	<script src="../libs/other/OrbitControls.js"></script>
	<script src="../libs/other/stats.min.js"></script>
	<script src="../libs/other/dat.gui.min.js"></script>
	
	<script src="../build/js/potree.js"></script>
	<script src="../build/js/laslaz.js"></script>
	<script src="../examples/js/ProgressBar.js"></script>
	<script src="../src/PointCloudOctree.js"></script>
	<script src="../src/utils/MeasuringTool.js"></script>
	<script src="../src/utils/AreaTool.js"></script>
	<script src="../src/utils/VolumeTool.js"></script>
	<script src="../src/utils/ProfileTool.js"></script>
	<script src="../src/utils/TransformationTool.js"></script>
	<script src="../src/materials/PointCloudMaterial.js"></script>
	<script src="viewer.js"></script>
		
	<div id="lblNumVisibleNodes" class="info" style="position: absolute; left: 10px; top: 80px; width: 400px; color:white"></div>
	<div id="lblNumVisiblePoints" class="info" style="position: absolute; left: 10px; top: 100px; width: 400px; color:white"></div>
	<div id="lblMessage" class="info" style="position: absolute; left: 10px; bottom: 0px; width: 400px; color:white"></div>
	
	<div id="tools" style="position: fixed; width: 400px; bottom: 10px; right: 10px">
		<input type="button" value="distance" onclick="measuringTool.setEnabled(true)"/>
		<input type="button" value="area" onclick="areaTool.setEnabled(true)"/>
		<input type="button" value="volume" onclick="volumeTool.startInsertion()"/>
		<input type="button" value="profile" onclick="profileTool.startPicking()"/>
		<input type="button" value="clip volume" onclick="volumeTool.startInsertion({clip: true})"/>
	
	</div>
	
	
	<div class="info" style="position: absolute; left: 300px; right: 300px; top: 10px; text-align: center;">
		<a href="http://potree.org" target="_blank">potree.org</a><br>
		Point cloud courtesy of <a href="http://www.sigeom.ch/" target="_blank">sigeom sa</a><br>
		
	</div>
	
	<div id="renderArea"></div>
	
	<script>
		var pointSize = 1.0 ;
		var pointCountTarget = 1;
		var opacity = 1;
		var pointSizeType = Potree.PointSizeType.ADAPTIVE;
		var pointColorType = Potree.PointColorType.RGB;
		var pointShape = Potree.PointShape.SQUARE;
		var interpolate = false;
		
		var showStats = false;
		
		var progressBar = new ProgressBar();

		var pointcloudPath = "../resources/pointclouds/vol_total/cloud.js";
	
		var elRenderArea = document.getElementById("renderArea");
	
		var renderer;
		var camera;
		var scene;
		var sceneBG, cameraBG;
		var pointcloud;
		var skybox;
		var stats;
		var clock = new THREE.Clock();
		var showSkybox = false;
		var measuringTool;
		var areaTool;
		var volumeTool;
		var transformationTool;
		var referenceFrame;
		
		function initGUI(){
		
			// dat.gui
			var gui = new dat.GUI({
				height : 5 * 32 - 1
			});
			
			var params = {
				"points(m)": pointCountTarget,
				PointSize: pointSize,
				"opacity": opacity,
				"SizeType" : "Adaptive",
				"show octree" : false,
				"Materials" : "RGB",
				"interpolate": interpolate,
				"circles": false,
				"skybox": false,
				"stats": showStats
			};
			
			var pPoints = gui.add(params, 'points(m)', 0.02, 2);
			pPoints.onChange(function(value){
				pointCountTarget = value ;
			});
			
			var pPointSize = gui.add(params, 'PointSize', 0, 3);
			pPointSize.onChange(function(value){
				pointSize = value;
			});
			
			var pOpacity = gui.add(params, 'opacity', 0, 1);
			pOpacity.onChange(function(value){
				opacity = value;
			});
			
			var pSizeType = gui.add(params, 'SizeType', [ "Fixed", "Attenuated", "Adaptive"]);
			pSizeType.onChange(function(value){
				if(value === "Fixed"){
					pointSizeType = Potree.PointSizeType.FIXED;
				}else if(value === "Attenuated"){
					pointSizeType = Potree.PointSizeType.ATTENUATED;
				}else if(value === "Adaptive"){
					pointSizeType = Potree.PointSizeType.ADAPTIVE;
				}
			});
			
			var pMaterial = gui.add(params, 'Materials', [ "RGB", "Color", "Height", "Octree Depth"]);
			pMaterial.onChange(function(value){
				if(value === "RGB"){
					pointColorType = Potree.PointColorType.RGB;
				}else if(value === "Color"){
					pointColorType = Potree.PointColorType.COLOR;
				}else if(value === "Height"){
					pointColorType = Potree.PointColorType.HEIGHT;
					
				}else if(value === "Octree Depth"){
					pointColorType = Potree.PointColorType.OCTREE_DEPTH;
				}else if(value === "Point Index"){
					pointColorType = Potree.PointColorType.POINT_INDEX;
				}
			});
			
			if(renderer.context.getExtension("EXT_frag_depth")){
				var pInterpolate = gui.add(params, 'interpolate');
				pInterpolate.onChange(function(value){
					interpolate = value;
				});
			}
			
			var pCircular = gui.add(params, 'circles');
			pCircular.onChange(function(value){
				if(value){
					pointShape = Potree.PointShape.CIRCLE;
				}else{
					pointShape = Potree.PointShape.SQUARE;
				}
			});
			
			var pSykbox = gui.add(params, 'skybox');
			pSykbox.onChange(function(value){
				showSkybox = value;
			});
			
			var pStats = gui.add(params, 'stats');
			pStats.onChange(function(value){
				showStats = value;
			});

			// stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.margin = '5px';
			document.body.appendChild( stats.domElement );
		}
		
		function initThree(){
			var fov = 75;
			var width = elRenderArea.clientWidth;
			var height = elRenderArea.clientHeight;
			var aspect = width / height;
			var near = 0.1;
			var far = 1000000;
		
			scene = new THREE.Scene();
			sceneBG = new THREE.Scene();
			
			camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
			//cameraBG = new THREE.OrthographicCamera(-100, 100, 100, -100, -100, 100);
			cameraBG = new THREE.Camera();
			//camera = new THREE.OrthographicCamera(-1000, 1000, 1000, -1000, -far, far);
			
			referenceFrame = new THREE.Object3D();
			scene.add(referenceFrame);

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(width, height);
			renderer.autoClear = false;
			elRenderArea.appendChild(renderer.domElement);
			
			skybox = Potree.utils.loadSkybox("../resources/textures/skybox/");

			// camera and controls
			camera.position.set(-304, 372, 318);
			camera.rotation.y = -Math.PI / 4;
			camera.rotation.x = -Math.PI / 6;
			controls = new THREE.FirstPersonControls(camera, renderer.domElement);
			controls.moveSpeed *= 10;
			
			//camera.position.set(0, 0, 100);
			//var sg = new THREE.SphereGeometry(1);
			//var s = new THREE.Mesh(sg);
			//s.scale.set(10,10,10);
			//scene.add(s);
			
			// enable frag_depth extension for the interpolation shader, if available
			renderer.context.getExtension("EXT_frag_depth");
			
			// load pointcloud
			POCLoader.load(pointcloudPath, function(geometry){
				pointcloud = new Potree.PointCloudOctree(geometry);
				
				pointcloud.material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
				pointcloud.material.size = pointSize;
				pointcloud.visiblePointsTarget = pointCountTarget * 1000 * 1000;
				
				//pointcloud.rotation.set(Math.PI/2, 0.85* -Math.PI/2, -0.0);
				
				referenceFrame.add(pointcloud);
				
				referenceFrame.applyMatrix(new THREE.Matrix4().set(
					1,0,0,0,
					0,0,1,0,
					0,-1,0,0,
					0,0,0,1
				));
				
				referenceFrame.updateMatrixWorld(true);
				var sg = pointcloud.boundingSphere.clone().applyMatrix4(pointcloud.matrixWorld);
				
				referenceFrame.position.copy(sg.center).multiplyScalar(-1);
				referenceFrame.position.y += sg.radius;
				
				referenceFrame.updateMatrixWorld(true);
				
				//zoomTo(camera, pointcloud, 0.7);
			});
			
			var grid = Potree.utils.createGrid(5, 5, 2);
			scene.add(grid);
			
			measuringTool = new Potree.MeasuringTool(scene, camera, renderer);
			areaTool = new Potree.AreaTool(scene, camera, renderer);
			volumeTool = new Potree.VolumeTool(scene, camera, renderer);
			transformationTool = new Potree.TransformationTool(scene, camera, renderer);
			profileTool = new Potree.ProfileTool(scene, camera, renderer);
			
			
			// bg, see http://stackoverflow.com/questions/19865537/three-js-set-background-image
			var texture = THREE.ImageUtils.loadTexture( '../resources/textures/background.jpg' );
			var bg = new THREE.Mesh(
				new THREE.PlaneGeometry(2, 2, 0),
				new THREE.MeshBasicMaterial({
					map: texture
				})
			);
			bg.material.depthTest = false;
			bg.material.depthWrite = false;
			sceneBG.add(bg);
			
			
			window.addEventListener( 'keydown', onKeyDown, false );
		}
		
		function onKeyDown(event){
			//console.log(event.keyCode);
			
			if(event.keyCode === 69){
				// e pressed
				
				transformationTool.translate();
			}else if(event.keyCode === 82){
				// r pressed
				
				transformationTool.scale();
			}else if(event.keyCode === 84){
				// r pressed
				
				transformationTool.rotate();
			}
		};
		
		function update(){
			if(pointcloud){
				pointcloud.material.size = pointSize;
				pointcloud.visiblePointsTarget = pointCountTarget * 1000 * 1000;
				pointcloud.material.opacity = opacity;
				pointcloud.material.pointSizeType = pointSizeType;
				pointcloud.material.pointColorType = pointColorType;
				pointcloud.material.pointShape = pointShape;
				pointcloud.material.interpolate = interpolate;
				pointcloud.material.heightMin = 0;
				pointcloud.material.heightMax = 8;
				
				pointcloud.update(camera, renderer);
			}
			
			if(showStats){
				document.getElementById("lblNumVisibleNodes").style.display = "";
			    document.getElementById("lblNumVisiblePoints").style.display = "";
			    stats.domElement.style.display = "";
			
				stats.update();
			
				if(pointcloud){
					document.getElementById("lblNumVisibleNodes").innerHTML = "visible nodes: " + pointcloud.numVisibleNodes;
					document.getElementById("lblNumVisiblePoints").innerHTML = "visible points: " + Potree.utils.addCommas(pointcloud.numVisiblePoints);
				}
			}else{
				document.getElementById("lblNumVisibleNodes").style.display = "none";
			    document.getElementById("lblNumVisiblePoints").style.display = "none";
			    stats.domElement.style.display = "none";
			}
			
			controls.update(clock.getDelta());

			// update progress bar
			if(pointcloud){
				var progress = pointcloud.visibleNodes.length / pointcloud.visibleGeometry.length;
				
				progressBar.progress = progress;
				progressBar.message = "loading: " + pointcloud.visibleNodes.length + " / " + pointcloud.visibleGeometry.length;
				
				if(progress === 1){
					progressBar.hide();
				}else if(progress < 1){
					progressBar.show();
				}
			}else{
				progressBar.show();
				progressBar.message = "loading metadata";
			}
			
			volumeTool.update();
			transformationTool.update();
			profileTool.update();
			
			
			var clipBoxes = [];
			
			for(var i = 0; i < profileTool.profiles.length; i++){
				var profile = profileTool.profiles[i];
				
				profile.box.updateMatrixWorld();
				var boxInverse = new THREE.Matrix4().getInverse(profile.box.matrixWorld);
				clipBoxes.push(boxInverse);
			}
			
			for(var i = 0; i < volumeTool.volumes.length; i++){
				var volume = volumeTool.volumes[i];
				
				if(volume.clip){
					volume.updateMatrixWorld();
					var boxInverse = new THREE.Matrix4().getInverse(volume.matrixWorld);
				
					clipBoxes.push(boxInverse);
				}
			}
			
			if(pointcloud){
				pointcloud.material.setClipBoxes(clipBoxes);
			}
			
		}
		
		function render(){
			// resize
			var width = elRenderArea.clientWidth;
			var height = elRenderArea.clientHeight;
			var aspect = width / height;
			
			//camera.aspect = aspect;
			camera.updateProjectionMatrix();
			
			renderer.setSize(width, height);
			
		
			// render skybox
			if(showSkybox){
				skybox.camera.rotation.copy(camera.rotation);
				renderer.render(skybox.scene, skybox.camera);
			}else{
				renderer.render(sceneBG, cameraBG);
			}
			
			// render scene
			
			renderer.render(scene, camera);
			
			profileTool.render();
			
			renderer.clearDepth();
			measuringTool.render();
			areaTool.render();
			transformationTool.render();
		}
		
		function loop() {
			requestAnimationFrame(loop);
			
			update();
			render();
		};
		
		
		
		initThree();
		initGUI();
		loop();
		
	</script>
	
</body>
</html>