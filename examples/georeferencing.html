<!doctype html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="http://openlayers.org/en/v3.0.0/css/ol.css" type="text/css">
    <style>
	
	body{
		margin: 0;
		padding: 0;
	}
	
	.map {
		position: absolute;
		height: 300px;
		width: 400px;
		right: 5px;
		bottom: 5px;
		z-index: 1000;
	}
	
	#renderArea{
		position: absolute;
		width: 100%;
		height: 100%;
		right: 0;
		bottom: 0;
		z-index: 0;
		margin: 0;
		padding: 0;
	}
	
	.info{
		position: absolute;
		z-index: 2000;
		color:white;
		font-weight: bold;
		text-shadow:  1px  1px 1px black,
					  1px -1px 1px black,
					 -1px  1px 1px black,
					 -1px -1px 1px black;
	}
	
	a:hover, a:visited, a:link, a:active{
		color: #ccccff;
		text-decoration: none;
	}
    </style>
    <script src="http://openlayers.org/en/v3.0.0/build/ol.js" type="text/javascript"></script>
	
	<script src="../libs/three.js/build/three.js"></script>
	<script src="../libs/other/dat.gui.min.js"></script>
	<script src="../libs/proj4/proj4.js"></script>
	
	<script src="../build/js/potree.js"></script>
	<script src="../src/loader/POCLoader.js"></script>
	<script src="../src/PointCloudOctree.js"></script>
	<script src="../src/PointCloudOctreeGeometry.js"></script>
	<script src="../src/utils/MeasuringTool.js"></script>
	<script src="../src/utils/ProfileTool.js"></script>
	
    <title>Georeferencing Example</title>
  </head>
  <body>
    <div id="map" class="map"></div>
	<div id="renderArea"></div>
	
	<div id="lblCoordinates" class="info" style="position: absolute; left: 5px; bottom: 10px">
	test
	</div>
	
	<!--<div class="info" style="position: absolute; left: 300px; right: 300px; top: 10px; text-align: center;">
		<a href="http://potree.org" target="_blank">potree.org</a><br>
		
		Georeferencing (sync with OpenLayers3) and Measurement.<br>
		Double click to generate measurement points. Measurement points will be displayed
		in the point cloud as well as the OpenStreetMap window.
		
		<br><br>
		Point cloud courtesy of <a href="http://www.sigeom.ch/" target="_blank">sigeom sa</a><br>
		Rue des Oeuches 45<br>
		2740 Moutier<br>
		Switzerland <br>

		<br>
		
	</div>-->
	
    <script type="text/javascript">

	var pointcloudPath = "../resources/pointclouds/vol_total/cloud.js";
	var pointcloudPath = "../../../../pointclouds/bruno_friedmann/vol_total/vol_total_bin/cloud.js";
	var defaultPointSize = 4;
	var defaultPointCountTarget = 1.5;
	
	// add EPSG:21781 to the proj4 projection database
	proj4.defs('EPSG:21781', "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=674.4,15.1,405.3,0,0,0,0 +units=m +no_defs ");
	var swiss = proj4.defs("EPSG:21781");
	var WGS84 = proj4.defs("WGS84");
	var webMercator = proj4.defs("EPSG:3857");
	
	// extent (with altitude) in EPSG:21781 / Swiss Coordinate System
	var minSwiss = [584757.154, 230878.747, 662.379];
	var maxSwiss = [593758.872, 232521.598, 850.323];
	
	// extent in EPSG:4326 / WGS84 World Geodetic System
	var minExtent = proj4(proj4.defs("EPSG:21781"), proj4.defs("WGS84"), [minSwiss[0], minSwiss[1]]);
	var maxExtent = proj4(proj4.defs("EPSG:21781"), proj4.defs("WGS84"), [maxSwiss[0], maxSwiss[1]]);
	
	// extent in EPSG:3857 / WGS84 Web Mercator 
	var minT = ol.proj.transform(minExtent, 'EPSG:4326', 'EPSG:3857');
	var maxT = ol.proj.transform(maxExtent, 'EPSG:4326', 'EPSG:3857');
	
	// the offset of the point cloud in EPSG:21781 coordinate system to local scene coordinates.
	// subtract this offset in order to move from local scene coordinates (obtained from picking, etc.) 
	// to EPSG:21781 coordinates
	var offset = new THREE.Vector3();
	
	var swissMin = new THREE.Vector3(485869.5728,  76443.1884, 0);
	var swissMax = new THREE.Vector3(837076.5648, 299941.7864, 0);

	
	// OpenLayers3 stuff
	var featureVector;
	var camFrustumFeatureVector;
	var camFrustum;
	var featureOverlay;
	var visibleBounds;
	
	// three.js / potree stuff
	var renderer;
	var scene, sceneHUD;
	var referenceFrame;
	var camera, cameraHUD;
	var skybox;
	var materials = {};
	var clock = new THREE.Clock();
	var measuringTool;
	var profileTool;
	var showCoordinates = false;
	var mouse = {x: 0, y: 0};
	var elCoordinates = document.getElementById("lblCoordinates");
	
	function initMapView(){
		
		var extent = [minT[0], minT[1], maxT[0], maxT[1]];
		var center = [(maxT[0] + minT[0]) / 2, (maxT[1] + minT[1]) / 2];
		
		// draw the extent as box inside the map view
		var box = new ol.geom.LineString([
			minT, [maxT[0], minT[1]], maxT, [minT[0], maxT[1]], minT
		]);
		visibleBounds = new ol.geom.LineString([
			minT, [maxT[0], minT[1]], maxT, [minT[0], maxT[1]], minT
		]);
		
		var feature = new ol.Feature(box);
		var visibleBoundsFeature = new ol.Feature(visibleBounds);
		featureVector = new ol.source.Vector({
			features: [feature, visibleBoundsFeature]
		});
		
		var layer = new ol.layer.Vector({
			source: featureVector,
			style: new ol.style.Style({
			fill: new ol.style.Fill({
			  color: 'rgba(255, 255, 255, 0.2)'
			}),
			stroke: new ol.style.Stroke({
			  color: '#000000',
			  width: 2
			}),
			image: new ol.style.Circle({
			  radius: 3,
			  fill: new ol.style.Fill({
				color: '#000000'
			  })
			})
		  })
		});	
		
		camFrustumFeatureVector = new ol.source.Vector({
			features: []
		});

		var camFrustumLayer = new ol.layer.Vector({
			source: camFrustumFeatureVector,
			style: new ol.style.Style({
			fill: new ol.style.Fill({
			  color: 'rgba(255, 255, 255, 0.2)'
			}),
			stroke: new ol.style.Stroke({
			  color: '#000000',
			  width: 2
			}),
			image: new ol.style.Circle({
			  radius: 3,
			  fill: new ol.style.Fill({
				color: '#000000'
			  })
			})
		  })
		});	
		
		// create the map
		var map = new ol.Map({
			controls: ol.control.defaults({
				attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
				collapsible: false
				})
			}).extend([
				new ol.control.ZoomToExtent({
					extent: extent,
					closest: true
				})
			]),
			layers: [
				new ol.layer.Tile({
					source: new ol.source.OSM()
				}),
				layer,
				camFrustumLayer
			],
			target: 'map',
			view: new ol.View({
				center: center,
				zoom: 12
			})
		});
		
		featureOverlay = new ol.FeatureOverlay({
		  style: new ol.style.Style({
			fill: new ol.style.Fill({
			  color: 'rgba(255, 255, 255, 0.2)'
			}),
			stroke: new ol.style.Stroke({
			  color: '#ff0000',
			  width: 2
			}),
			image: new ol.style.Circle({
			  radius: 7,
			  fill: new ol.style.Fill({
				color: '#ff0000'
			  })
			})
		  })
		});
		featureOverlay.setMap(map);
		
		var modify = new ol.interaction.Modify({
		  features: featureOverlay.getFeatures(),
		  // the SHIFT key must be pressed to delete vertices, so
		  // that new vertices can be drawn at the same position
		  // of existing vertices
		  deleteCondition: function(event) {
			return ol.events.condition.shiftKeyOnly(event) &&
				ol.events.condition.singleClick(event);
		  }
		});
		map.addInteraction(modify);

		var draw; // global so we can remove it later
		function addInteraction() {
		  draw = new ol.interaction.Draw({
			features: featureOverlay.getFeatures(),
			//source: camFrustumFeatureVector,
			type: /** @type {ol.geom.GeometryType} */ ("LineString")
		  });
		  map.addInteraction(draw);
		}		
		addInteraction();
	}
	
	function initPotreeView(){
		var renderArea = document.getElementById("renderArea");
		var near = 0.1;
		var far = 1000000;
		var fov = 60;
		
		var aspect = renderArea.clientWidth / renderArea.clientHeight;
		scene = new THREE.Scene();
		sceneHUD = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		cameraHUD = new THREE.OrthographicCamera( -1, 1, 1, -1, -100, 1000 );

		renderer = new THREE.WebGLRenderer();
		renderer.setSize(renderArea.clientWidth, renderArea.clientHeight);
		renderer.autoClear = false;
		renderArea.appendChild(renderer.domElement);
		
		skybox = Potree.utils.loadSkybox("../resources/textures/skybox/");
		
		camera.position.set(500, 200, -300);
		controls = new THREE.FirstPersonControls(camera, renderer.domElement);
		camera.rotation.order = 'ZYX';
		camera.rotation.x = -0.5;
		camera.rotation.y = -5*Math.PI/4;
		controls.moveSpeed *= 10;
		
		materials.rgb = new Potree.PointCloudRGBMaterial({ size: defaultPointSize});
		materials.rgbInterpolated = new Potree.PointCloudRGBInterpolationMaterial({ size: defaultPointSize});
		materials.height = new Potree.PointCloudHeightMaterial({size: defaultPointSize, min: 650, max: 850});
		
		// load pointcloud
		var pco = POCLoader.load(pointcloudPath, {toOrigin: true});
		offset = pco.offset;
		pointcloud = new Potree.PointCloudOctree(pco, materials.rgb);
		pointcloud.visiblePointsTarget = defaultPointCountTarget * 1000 * 1000;
		
		// the reference frame transforms the point cloud into the scene coordinate system
		// by moving it towards the origin and flipping the y and t axes.
		// This is necessary to avoid precision errors due to large floating point values.
		referenceFrame = new THREE.Object3D();
		referenceFrame.position.set(-pointcloud.position.x, -pointcloud.position.y, 0);
		referenceFrame.updateMatrix();
		referenceFrame.applyMatrix(new THREE.Matrix4().set(
			1,0,0,0,
			0,0,1,0,
			0,-1,0,0,
			0,0,0,1
		));
		scene.add(referenceFrame);
		
		referenceFrame.add(pointcloud);
		referenceFrame.updateMatrixWorld();
		
		measuringTool = new Potree.MeasuringTool(scene, camera, renderer.domElement);
		
		// execute this event whenever a new measurement point has been set
		measuringTool.addEventListener("newpoint", function(event){
			point = toGeo(event.position);
			
			// transform from swiss projection to WGS84
			var swiss = proj4.defs("EPSG:21781");
			var WGS84 = proj4.defs("WGS84");
			var coordinate = proj4(swiss, WGS84, [point.x, point.y]);
			
			// transform from WGS84 to Web Mercator
			coordinate = ol.proj.transform(coordinate, 'EPSG:4326', 'EPSG:3857');
	
			// add a point to the OpenLayers map
			var olPoint = new ol.geom.Point(coordinate);
			var feature = new ol.Feature(olPoint);
			featureVector.addFeature(feature);
		});
		
		profileTool = new Potree.ProfileTool(400, 200, 10);
		profileTool.position.set(0,0,0);
		scene.add(profileTool);
		sceneHUD.add(profileTool.hudElement);
		
		camera.position.copy(toLocal(new THREE.Vector3(590027, 231745, 907)));
		camera.position.copy(new THREE.Vector3(6000, 3200, -4600));
		camera.lookAt(toLocal(new THREE.Vector3(589962, 231462, 750)));
		
		renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
		
		
		//var lblMax = new Potree.TextSprite("max");
		//sceneHUD.add(lblMax);
	}
	
	function toLocal(position){
		var scenePos = position.clone().applyMatrix4(referenceFrame.matrixWorld);
		return scenePos;
	}
	
	function toGeo(object){
		var geo;
		var inverse = new THREE.Matrix4().getInverse(referenceFrame.matrixWorld);
		
		if(object instanceof THREE.Vector3){	
			geo = object.clone().applyMatrix4(inverse);
		}else if(object instanceof THREE.Box3){
			var geoMin = object.min.clone().applyMatrix4(inverse);
			var geoMax = object.max.clone().applyMatrix4(inverse);
			geo = new THREE.Box3(geoMin, geoMax);
		}

		return geo;
	}
	
	function initGUI(){
	
		// dat.gui
		var gui = new dat.GUI({
			height : 5 * 32 - 1
		});
		
		var params = {
			PointSize: defaultPointSize,
			"points(m)": defaultPointCountTarget,
			"show octree" : false,
			"coordinates" : showCoordinates,
			"Materials" : materials.rgb
		};
		
		var pPoints = gui.add(params, 'points(m)', 0.2, 2);
			pPoints.onChange(function(value){
				pointcloud.visiblePointsTarget = value * 1000 * 1000;
		});
		
		var pPointSize = gui.add(params, 'PointSize', 0.01, 6.0);
		pPointSize.onChange(function(value){
			pointcloud.material.size = value;
		});

		var pMaterial = gui.add(params, 'Materials', [ "RGB", "RGB High Quality", "Height" ]);
		pMaterial.onChange(function(value){
			var size = pointcloud.material.size;
			if(value === "RGB"){
				pointcloud.material = materials.rgb;
			}else if(value === "RGB High Quality"){
				var frag_depth_ext = renderer.context.getExtension('EXT_frag_depth');
				if(!frag_depth_ext){
					var message = "failed to load EXT_frag_depth. This extension is required for the high quality shader.\n";
					message += "using standard RGB material instead";
					alert(message);
					pointcloud.material = materials.rgb;
				}else{
					pointcloud.material = materials.rgbInterpolated;
				}
				
			}else if(value === "Height"){
				pointcloud.material = materials.height;
			}
			
			pointcloud.material.size = size;
		
			console.log(value);
		});
		
		var pBoundingBox = gui.add(params, 'show octree');
		pBoundingBox.onChange(function(value){
			pointcloud.showBoundingBox = value;
		});
		
		var pCoordinates = gui.add(params, 'coordinates');
		pCoordinates.onChange(function(value){
			showCoordinates = value;
		});
	}
	
	function update(){
		controls.update(clock.getDelta());
		pointcloud.update(camera);
	
		updateMapFrustum();
		
		updateCoordinatePicking();
		
		updateProfile();
		
		updateMapExtent();
	}
	
	function updateMapFrustum(){
		if(camFrustum === undefined){
			camFrustum = new ol.geom.LineString([ [0,0], [0, 0] ]);
			var feature = new ol.Feature(camFrustum);
			camFrustumFeatureVector.addFeature(feature);
		}
	
		var aspect = camera.aspect;
		var top = Math.tan( THREE.Math.degToRad( camera.fov * 0.5 ) ) * camera.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		
		var camPos = new THREE.Vector3(0, 0, 0);
		left = new THREE.Vector3(left, 0, -camera.near).multiplyScalar(3000);
		right = new THREE.Vector3(right, 0, -camera.near).multiplyScalar(3000);
		camPos.applyMatrix4(camera.matrixWorld);
		left.applyMatrix4(camera.matrixWorld);
		right.applyMatrix4(camera.matrixWorld);
		
		camPos = toGeo(camPos);
		left = toGeo(left);
		right = toGeo(right);
		
		camPos = proj4(swiss, webMercator, [camPos.x, camPos.y]);
		left = proj4(swiss, webMercator, [left.x, left.y]);
		right = proj4(swiss, webMercator, [right.x, right.y]);
		
		camFrustum.setCoordinates([camPos, left, right, camPos]);
	}
	
	function updateCoordinatePicking(){
		if(showCoordinates){
			
			var I = getMousePointCloudIntersection();
			if(I !== undefined){
				
				var sceneCoordinates = I;
				var geoCoordinates = toGeo(sceneCoordinates);
				
				var msg = "EPSG:21781: " + geoCoordinates.x.toFixed(2) + " / ";
				msg += geoCoordinates.y.toFixed(2) + " / ";
				msg += geoCoordinates.z.toFixed(2);
				msg += "  -  sceneCoordinates: " + sceneCoordinates.x.toFixed(2) + " / ";
				msg += sceneCoordinates.y.toFixed(2) + " / ";
				msg += sceneCoordinates.z.toFixed(2);
				
				elCoordinates.innerHTML = msg;
			}
		}else{
			elCoordinates.innerHTML = "";
		}
	}
	
	function updateMapExtent(){
		var geoExtent = toGeo(pointcloud.getVisibleExtent());
		
		geoMin = proj4(swiss, webMercator, [geoExtent.min.x, geoExtent.min.y]);
		geoMax = proj4(swiss, webMercator, [geoExtent.max.x, geoExtent.max.y]);
		
		visibleBounds.setCoordinates([
			geoMin,
			[geoMax[0], geoMin[1]],
			geoMax,
			[geoMin[0], geoMax[1]],
			geoMin
		]);
	}
	
	function updateProfile(){
		var features = featureOverlay.getFeatures();
		if(features.getArray().length == 0){
			return;
		}
		
		var geometry = featureOverlay.getFeatures().getArray()[0].getGeometry();
		var coordinates = geometry.getCoordinates();
		
		if(coordinates.length < 2){
			return;
		}
		
		var start = new THREE.Vector3(coordinates[0][0], coordinates[0][1], 0);
		var end = new THREE.Vector3(coordinates[1][0], coordinates[1][1], 0);
		
		var swiss = proj4.defs("EPSG:21781");
		var WGS84 = proj4.defs("WGS84");
		var webMercator = proj4.defs("EPSG:3857");
		
		var startSwiss = proj4(webMercator, swiss, [start.x, start.y]);
		var startScene = toLocal(new THREE.Vector3(startSwiss[0], startSwiss[1], 0));
		
		var endSwiss = proj4(webMercator, swiss, [end.x, end.y]);
		var endScene = toLocal(new THREE.Vector3(endSwiss[0], endSwiss[1], 0));
		
		startScene.y = 750;
		endScene.y = 750;
		
		profileTool.setCoordinates(startScene, endScene);

	}
	
	function getMousePointCloudIntersection(){
		var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
		var projector = new THREE.Projector();
		projector.unprojectVector( vector, camera );
		
		var raycaster = new THREE.Raycaster();
		raycaster.params = {"PointCloud" : {threshold: 1}};
		raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );
		
		var pointClouds = [];
		scene.traverse(function(object){
			if(object instanceof Potree.PointCloudOctree){
				pointClouds.push(object);
			}
		});
		
		var intersects = raycaster.intersectObjects(pointClouds, true);
		
		if(intersects.length > 0){
			var I = intersects[0];			
			
			return I.point;
		}else{
			return undefined;
		}
	}
	
	function render(){
		// resize 
		var renderArea = document.getElementById("renderArea");
		var width = renderArea.clientWidth;
		var height = renderArea.clientHeight;
		
		renderer.setSize(width, height-10);
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
		
		profileTool.hudElement.scale.x = 400 / width;
		profileTool.hudElement.scale.y = 300 / height;
		profileTool.hudElement.position.x = 1 - 405 / width;
		profileTool.hudElement.position.y = -1 + 905 / height;

		// render skybox
		skybox.camera.rotation.copy(camera.rotation);
		renderer.render(skybox.scene, skybox.camera);
		
		// render scenes
		renderer.render(scene, camera);
		renderer.render(measuringTool.sceneMeasurement, camera);
		renderer.render(sceneHUD, cameraHUD);
		profileTool.render(renderer, scene);
		
	}
	
	function profileTest(){
		var start = profileTool.start;
		var end = profileTool.end;
		
		//pointcloud.getProfile(start, end, 10, 3);
		
		//var start = new THREE.Vector3(5399.144872280038, 756.553841534622, -588.2956906469327);
		//var end = new THREE.Vector3(5008.626665211386, 750.8961536111632, -585.8724566535059);
		//var start = startScene;
		//var end = endScene;
		var width = 10;
		var depth = 5;
		
		
		var callback = function(event){
			if(event.type === "finished"){
				var points = event.points;
				var sphereGeometry = new THREE.SphereGeometry(1, 5, 5);
				for(var i = 0; i < points.length; i += Math.ceil(points.length / 100)){
					var point = points[i];
					var sphere = new THREE.Mesh(sphereGeometry);
					sphere.position.copy(point);
					scene.add(sphere);
				}
			}
		};
		
		var points = pointcloud.getProfile(start, end, width, depth, callback);
		
		//var sphereGeometry = new THREE.SphereGeometry(1);
		//for(var i = 0; i < points.length; i++){
		//	var point = points[i];
		//	var sphere = new THREE.Mesh(sphereGeometry);
		//	sphere.position.copy(point);
		//	scene.add(sphere);
		//}
		//
		//console.log(points);
	}
	
	function onMouseMove(event){
		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
	};
	
	function loop(){
		requestAnimationFrame(loop);
	
		update();
		render();
	}
	
	initMapView();
	initPotreeView();
	initGUI();
	loop();

    </script>
  </body>
</html>